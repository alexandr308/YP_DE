
## Описание проекта
Ваш заказчик — компания, которая разрабатывает приложение по доставке еды.
Вам необходимо составить витрину для RFM-классификации пользователей приложения.

## Что такое RFM
RFM (от англ. Recency Frequency Monetary Value) — способ сегментации клиентов, при котором анализируют их лояльность: как часто, на какие суммы и когда в последний раз тот или иной клиент покупал что-то. На основе этого выбирают клиентские категории, на которые стоит направить маркетинговые усилия.
Каждого клиента оценивают по трём факторам:
Recency (пер. «давность») — сколько времени прошло с момента последнего заказа.
Frequency (пер. «частота») — количество заказов.
Monetary Value (пер. «денежная ценность») — сумма затрат клиента.

## Как провести RFM-сегментацию
1. Присвойте каждому клиенту три значения — значение фактора Recency, значение фактора Frequency и значение фактора Monetary:
 - Фактор Recency измеряется по последнему заказу. Распределите клиентов по шкале от одного до пяти, где значение 1 получат те, кто либо вообще не делал заказов, либо делал их очень давно, а 5 — те, кто заказывал относительно недавно.
 - Фактор Frequency оценивается по количеству заказов. Распределите клиентов по шкале от одного до пяти, где значение 1 получат клиенты с наименьшим количеством заказов, а 5 — с наибольшим.
 - Фактор Monetary оценивается по потраченной сумме. Распределите клиентов по шкале от одного до пяти, где значение 1 получат клиенты с наименьшей суммой, а 5 — с наибольшей.
2. Проверьте, что количество клиентов в каждом сегменте одинаково. Например, если в базе всего 100 клиентов, то 20 клиентов должны получить значение 1, ещё 20 — значение 2 и т. д.


# 1. Построение витрины для RFM-анализа

Получен доступ к базе данных компании. В базе две схемы: _production_ и _analysis_. В схеме production содержатся оперативные таблицы.
Задача — построить витрину для RFM-классификации. Для анализа нужно отобрать только **_успешно_** выполненные заказы.

## 1.1. Требования к целевой витрине

Название витрины - **dm_rfm_segments**.
Витрина должна располагаться в той же базе в схеме analysis.
Витрина должна состоять из таких полей:
- user_id
- recency (число от 1 до 5)
- frequency (число от 1 до 5)
- monetary_value (число от 1 до 5)

В витрине нужны данные с начала 2021 года.
Обновления не нужны.
Это заказ со статусом **Closed**.

## 1.2. Изучение структуры исходных данных

Подключение к базе данных. 
Сначала запустил docker командой docker run -d --rm -p 3030:3030 -p 15432:5432 
--name=de-project-sprint-1-server-local sindb/project-sprint-1:latest
Затем через бобра подключился через порт 15432.

В схеме production имеется 6 таблиц (одна для задания 2): orderitems связывающая заказы и продукты; 
orders собственно заказы; orderstatuses статусы заказов; products продукты; users пользователи.

Сначала из таблицы заказов нужно вытащить только завершенные заказы сразу ограничась данными не раньше 2021 года. 
Ко всем пользователям приджойнить все выполненные заказы.
Добавить данные по стоимости заказов.

Для этого нужны поля следующих таблиц:
users - user_id - для отбора всех пользователей
orderstatuses - id, key - для фильтрации
orders - order_id, user_id, order_ts, cost, status

## 1.3. Анализ качества данных

**Качество данных.**

Проверка на дубли c помощью подсчета кол-ва уникальных значений и общего кол-ва записей - все таблицы без дублей.
Проверка на пропски - судя по свойствам таблиц все поля не допускают наличия пропусков, кроме поля name таблицы users, но оно нам не нужно.
Форматы и типы выглядят логично для всех полей. Вот только описание статуса в поле key таблицы orderstatuses и полей name, login таблицы users можно было бы ограничить длиной поменьше.

**Инстументы обеспечения качества данных.**

Использование ограничений на наловые значения практически во всех полях всех таблиц.
Каждая таблица имеет первичные ключи, талица orderitems имеет внешние ключи.
Также присутствуют логичные ограничения по размеру скидки относительно цены, цена больше нуля и прочие.

## 1.4. Подготовка витрины данных

Скрипты в папке /src

# 2. Доработка представлений

Вместо поля с одним статусом разработчики добавили таблицу для журналирования всех изменений статусов заказов — **production.OrderStatusLog**.

Структура таблицы production.OrderStatusLog:
id — синтетический автогенерируемый идентификатор записи,
order_id — идентификатор заказа, внешний ключ на таблицу production.Orders,
status_id — идентификатор статуса, внешний ключ на таблицу статусов заказов production.OrderStatuses,
dttm — дата и время получения заказом этого статуса.

Чтобы скрипт по расчёту витрины продолжил работать, необходимо внести изменения в то, как формируется представление analysis.Orders: вернуть в него поле status. Значение в этом поле должно соответствовать последнему по времени статусу из таблицы production.OrderStatusLog.
